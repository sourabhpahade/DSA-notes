

Que:

Given an array arr of size N. Your task is to determine that if by reversing any one subarray can the given array be sorted or not.

--------------------------------------------------------------------------------------

Logic: Brute-force => 1. Reversing a subarray.
					  2. checking it if it is aking array sorted or not
					  3. if not then reversing it to make original array
					  4. cheking another subarray

					  time complex. n^3.

	    Optimized approach => The idea is to compare the given array with its sorted  version. Make a copy of the given array and sort it. Now, find the first index and last index in the given array which does not match with the sorted array. If no such indices are found (given array was already sorted), return True. Else check if the elements between the found indices are in decreasing order, if Yes then return True else return False
--------------------------------------------------------------------------------------------

Code: Bruteforce

		int size=2;
		int start = 0;
		
		while(size<=N){
			int end = start + size-1;
			boolean check = true;
			
			reverse(arr,start,end);
			
			for(int i=0;i<N-1;i++){
				if(arr[i]>arr[i+1]){
					check=false;
					break;
				}
			}
				
			if(check==false){
				reverse(arr,start,end);
			}else{
				return true;
			}
				start++;
				if(start>N-size){
					start=0;
					size++;
				}	
		}
		return false;
--------------------------------------------------------------

code - optimized 

	    // Copying the array.
        int temp[] = new int[n];
        for (int i = 0; i < n; i++) {
            temp[i] = arr[i];
        }
 
        // Sort the copied array.
        Arrays.sort(temp);
 
        // Finding the first mismatch.
        int front;
        for (front = 0; front < n; front++) {
            if (temp[front] != arr[front]) {
                break;
            }
        }
 
        // Finding the last mismatch.
        int back;
        for (back = n - 1; back >= 0; back--) {
            if (temp[back] != arr[back]) {
                break;
            }
        }
 
        // If whole array is sorted
        if (front >= back) {
            return true;
        }
 
        // Checking subarray is decreasing or not.
        do {
            front++;
            if (arr[front - 1] < arr[front]) {
                return false;
            }
        } while (front != back);
 
        return true;